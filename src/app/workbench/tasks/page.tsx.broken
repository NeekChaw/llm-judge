'use client';

import { Button } from '@/components/ui/button';
import Link from 'next/link';
import { useState, useEffect } from 'react';
import { Play, Clock, CheckCircle, XCircle, PlusCircle, Activity, RefreshCw, Copy, Search, Filter, ChevronLeft, ChevronRight, DollarSign, BarChart3 } from 'lucide-react';
import { apiClient } from '@/lib/api-client';
import { useUserPreferences } from '@/lib/user-preferences';
import { formatCost } from '@/lib/cost-calculator';
import { 
  checkAggregationCompatibility, 
  TaskForAggregation, 
  AggregationCompatibility,
  AggregationType,
  createAggregationId,
  mergeModelsForVerticalAggregation,
  mergeDimensionsForHorizontalAggregation
} from '@/lib/aggregation-utils';
import { useRouter } from 'next/navigation';

interface TaskStats {
  total: number;
  running: number;
  completed: number;
  failed: number;
  pending: number;
}

interface Task {
  id: string;
  name: string;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';
  created_at: string;
  started_at?: string;
  finished_at?: string;
  progress: {
    total: number;
    completed: number;
    failed: number;
  };
  // ğŸ†• æ·»åŠ å¤šæ¬¡è¿è¡Œç›¸å…³å­—æ®µ
  config?: {
    run_count?: number;
    [key: string]: any;
  };
  // ğŸ†• æ·»åŠ æˆæœ¬ä¿¡æ¯
  cost_summary?: {
    total_cost_usd: number;
    total_cost_cny: number;
    has_cost_data: boolean;
    model_count: number;
  };
}

export default function WorkbenchPage() {
  const { currency } = useUserPreferences();
  const router = useRouter();
  const [tasks, setTasks] = useState<Task[]>([]);
  const [stats, setStats] = useState<TaskStats>({
    total: 0,
    running: 0,
    completed: 0,
    failed: 0,
    pending: 0
  });
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  // ğŸ†• å±€éƒ¨åŠ è½½çŠ¶æ€
  const [paginationLoading, setPaginationLoading] = useState(false);

  // ğŸš€ ç¼“å­˜æœºåˆ¶
  const [taskCache, setTaskCache] = useState<Map<string, {
    tasks: Task[];
    pagination: any;
    stats: any; // ğŸ†• ç¼“å­˜ç»Ÿè®¡æ•°æ®
    timestamp: number;
  }>>(new Map());
  const CACHE_DURATION = 5 * 60 * 1000; // 5åˆ†é’Ÿç¼“å­˜
  // ğŸ†• å…‹éš†ä»»åŠ¡ç›¸å…³çŠ¶æ€
  const [showCloneDialog, setShowCloneDialog] = useState(false);
  const [cloneTaskId, setCloneTaskId] = useState<string | null>(null);
  const [cloneTaskName, setCloneTaskName] = useState('');
  const [cloning, setCloning] = useState(false);

  // ğŸ†• å¤šé€‰ä»»åŠ¡ç›¸å…³çŠ¶æ€
  const [selectedTasks, setSelectedTasks] = useState<Set<string>>(new Set());
  const [isMultiSelectMode, setIsMultiSelectMode] = useState(false);
  const [aggregationCompatibility, setAggregationCompatibility] = useState<AggregationCompatibility | null>(null);
  const [selectedTasksInfo, setSelectedTasksInfo] = useState<TaskForAggregation[]>([]);
  const [loadingCompatibility, setLoadingCompatibility] = useState(false);

  // ğŸ†• ç­›é€‰å’Œåˆ†é¡µçŠ¶æ€
  const [searchName, setSearchName] = useState('');
  const [statusFilter, setStatusFilter] = useState<string>('all');
  const [typeFilter, setTypeFilter] = useState<string>('all');
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [totalTasks, setTotalTasks] = useState(0);
  const pageSize = 10;

  // ğŸš€ ç¼“å­˜è¾…åŠ©å‡½æ•°
  const getCacheKey = (page: number, search: string, status: string, type: string) => {
    return `${page}-${search}-${status}-${type}`;
  };

  const getCachedData = (cacheKey: string) => {
    const cached = taskCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
      return cached;
    }
    return null;
  };

  const setCachedData = (cacheKey: string, tasks: Task[], pagination: any, stats: any) => {
    const newCache = new Map(taskCache);
    newCache.set(cacheKey, {
      tasks,
      pagination,
      stats, // ğŸ†• ç¼“å­˜ç»Ÿè®¡æ•°æ®
      timestamp: Date.now()
    });
    setTaskCache(newCache);
  };

  const clearCache = () => {
    setTaskCache(new Map());
  };

  // ğŸš€ é¢„åŠ è½½ä¸‹ä¸€é¡µ
  const preloadNextPage = async (currentPage: number) => {
    if (currentPage < totalPages) {
      const nextPage = currentPage + 1;
      const nextCacheKey = getCacheKey(nextPage, searchName, statusFilter, typeFilter);

      // æ£€æŸ¥ä¸‹ä¸€é¡µæ˜¯å¦å·²ç¼“å­˜
      if (!getCachedData(nextCacheKey)) {
        console.log('ğŸ”® é¢„åŠ è½½ä¸‹ä¸€é¡µ:', nextPage);

        // åœ¨åå°é™é»˜åŠ è½½ä¸‹ä¸€é¡µ
        try {
          const params: any = {
            page: nextPage,
            limit: pageSize,
          };

          if (searchName.trim()) {
            params.search = searchName.trim();
          }

          if (statusFilter !== 'all') {
            params.status = statusFilter;
          }

          if (typeFilter !== 'all') {
            params.type = typeFilter === 'single' ? 'single' : 'multi';
          }

          const response = await apiClient.getTasks(params);

          if (response.data) {
            const tasksData = response.data.tasks.map(task => ({
              id: task.id,
              name: task.name,
              status: task.status as Task['status'],
              created_at: task.created_at,
              started_at: task.started_at,
              finished_at: task.finished_at,
              progress: task.progress,
              config: task.config
            }));

            // ç¼“å­˜é¢„åŠ è½½çš„æ•°æ®
            setCachedData(nextCacheKey, tasksData, response.data.pagination, response.data.stats);
            console.log('âœ… ä¸‹ä¸€é¡µé¢„åŠ è½½å®Œæˆ');
          }
        } catch (error) {
          console.log('âš ï¸ é¢„åŠ è½½å¤±è´¥:', error);
          // é¢„åŠ è½½å¤±è´¥ä¸å½±å“ç”¨æˆ·ä½“éªŒ
        }
      }
    }
  };

  const loadTasks = async (page = currentPage, loadingType: 'full' | 'pagination' | 'none' = 'full', forceRefresh = false) => {
    try {
      setError(null);

      // ğŸš€ æ£€æŸ¥ç¼“å­˜
      const cacheKey = getCacheKey(page, searchName, statusFilter, typeFilter);
      if (!forceRefresh) {
        const cachedData = getCachedData(cacheKey);
        if (cachedData) {
          console.log('ğŸ¯ ä½¿ç”¨ç¼“å­˜æ•°æ®:', cacheKey);
          setTasks(cachedData.tasks);
          setCurrentPage(cachedData.pagination.page);
          setTotalPages(cachedData.pagination.totalPages);
          setTotalTasks(cachedData.pagination.total);

          // ğŸ†• è®¾ç½®ç¼“å­˜çš„ç»Ÿè®¡æ•°æ®
          if (cachedData.stats) {
            setStats(cachedData.stats);
          }

          // ğŸš€ é¢„åŠ è½½ä¸‹ä¸€é¡µ
          preloadNextPage(page);
          return;
        }
      }

      // ğŸ†• æ ¹æ®åŠ è½½ç±»å‹è®¾ç½®ä¸åŒçš„loadingçŠ¶æ€
      if (loadingType === 'full') {
        setLoading(true);
      } else if (loadingType === 'pagination') {
        setPaginationLoading(true);
      }

      console.log('ğŸŒ ä»APIåŠ è½½æ•°æ®:', cacheKey);

      // æ„å»ºæŸ¥è¯¢å‚æ•°
      const params: any = {
        page,
        limit: pageSize,
      };

      if (searchName.trim()) {
        params.search = searchName.trim();
      }

      if (statusFilter !== 'all') {
        params.status = statusFilter;
      }

      // ğŸ†• æ·»åŠ ç±»å‹ç­›é€‰å‚æ•°
      if (typeFilter !== 'all') {
        params.type = typeFilter === 'single' ? 'single' : 'multi';
      }

      const response = await apiClient.getTasks(params);
      
      if (response.error) {
        setError(response.error);
        return;
      }

      if (response.data) {
        const tasksData = response.data.tasks.map(task => ({
          id: task.id,
          name: task.name,
          status: task.status as Task['status'],
          created_at: task.created_at,
          started_at: task.started_at,
          finished_at: task.finished_at,
          progress: task.progress,
          config: task.config // ğŸ†• åŒ…å«é…ç½®ä¿¡æ¯
        }));

        setTasks(tasksData);

        // ğŸ†• è®¾ç½®åˆ†é¡µä¿¡æ¯
        if (response.data.pagination) {
          setCurrentPage(response.data.pagination.page);
          setTotalPages(response.data.pagination.totalPages);
          setTotalTasks(response.data.pagination.total);

          // ğŸš€ ç¼“å­˜æ•°æ®
          setCachedData(cacheKey, tasksData, response.data.pagination, response.data.stats);
        }

        // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨APIè¿”å›çš„ç»Ÿè®¡æ•°æ®
        if (response.data.stats) {
          setStats(response.data.stats);
        } else {
          // å…¼å®¹æ—§APIï¼Œä½¿ç”¨å½“å‰é¡µæ•°æ®è®¡ç®—
          const taskStats = tasksData.reduce((acc, task) => {
            acc.total++;
            if (task.status === 'running') acc.running++;
            else if (task.status === 'completed') acc.completed++;
            else if (task.status === 'failed') acc.failed++;
            else if (task.status === 'pending') acc.pending++;
            return acc;
          }, { total: totalTasks, running: 0, completed: 0, failed: 0, pending: 0 });

          setStats(taskStats);
        }

        // ğŸš€ é¢„åŠ è½½ä¸‹ä¸€é¡µ
        preloadNextPage(page);
      }
    } catch (error) {
      console.error('åŠ è½½ä»»åŠ¡å¤±è´¥:', error);
      setError('åŠ è½½ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      // ğŸ†• æ ¹æ®åŠ è½½ç±»å‹ç»“æŸå¯¹åº”çš„loadingçŠ¶æ€
      if (loadingType === 'full') {
        setLoading(false);
      } else if (loadingType === 'pagination') {
        setPaginationLoading(false);
      }
      setRefreshing(false);
    }
  };

  useEffect(() => {
    loadTasks(1, 'full'); // åˆå§‹åŠ è½½ä½¿ç”¨å…¨å±loading
  }, []);

  // ğŸ†• å½“ç­›é€‰æ¡ä»¶å˜åŒ–æ—¶é‡æ–°åŠ è½½
  useEffect(() => {
    if (searchName || statusFilter !== 'all' || typeFilter !== 'all') {
      // ğŸš€ ç­›é€‰æ¡ä»¶å˜åŒ–æ—¶ï¼Œå…ˆæ£€æŸ¥ç¼“å­˜
      loadTasks(1, 'none'); // ç­›é€‰å˜åŒ–æ—¶ä¸æ˜¾ç¤ºloadingï¼Œå› ä¸ºæ˜¯å³æ—¶ç­›é€‰
    }
  }, [searchName, statusFilter, typeFilter]);

  const handleRefresh = async () => {
    setRefreshing(true);
    clearCache(); // ğŸš€ æ¸…é™¤ç¼“å­˜ï¼Œå¼ºåˆ¶åˆ·æ–°
    await loadTasks(currentPage, 'none', true); // å¼ºåˆ¶åˆ·æ–°
  };

  // ğŸ†• å¤„ç†æœç´¢
  const handleSearch = async () => {
    setCurrentPage(1);
    await loadTasks(1, 'none'); // æœç´¢æ—¶ä¸æ˜¾ç¤ºloadingï¼Œå› ä¸ºæ˜¯å³æ—¶æœç´¢
  };

  // ğŸ†• å¤„ç†ç­›é€‰å˜åŒ–
  const handleFilterChange = async (filterType: string, value: string) => {
    if (filterType === 'status') {
      setStatusFilter(value);
    } else if (filterType === 'type') {
      setTypeFilter(value);
    }
    setCurrentPage(1);
    await loadTasks(1, 'none'); // ç­›é€‰å˜åŒ–æ—¶ä¸æ˜¾ç¤ºloading
  };

  // ğŸ†• å¤„ç†åˆ†é¡µ - ä½¿ç”¨å±€éƒ¨åŠ è½½
  const handlePageChange = async (page: number) => {
    if (page >= 1 && page <= totalPages) {
      setCurrentPage(page);
      await loadTasks(page, 'pagination'); // ğŸ”§ ä½¿ç”¨åˆ†é¡µloadingï¼Œä¸æ˜¯å…¨å±loading
    }
  };

  // ğŸ†• å¤„ç†å…‹éš†ä»»åŠ¡
  const handleCloneTask = (taskId: string, taskName: string) => {
    setCloneTaskId(taskId);
    setCloneTaskName(`${taskName} - å‰¯æœ¬`);
    setShowCloneDialog(true);
  };

  // ğŸ†• æ‰§è¡Œå…‹éš†ä»»åŠ¡
  const executeCloneTask = async () => {
    if (!cloneTaskId || !cloneTaskName.trim()) return;

    setCloning(true);
    try {
      const response = await fetch(`/api/tasks/${cloneTaskId}/clone`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: cloneTaskName.trim(),
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'å…‹éš†ä»»åŠ¡å¤±è´¥');
      }

      const result = await response.json();

      // å…³é—­å¯¹è¯æ¡†
      setShowCloneDialog(false);
      setCloneTaskId(null);
      setCloneTaskName('');

      // åˆ·æ–°ä»»åŠ¡åˆ—è¡¨
      clearCache(); // ğŸš€ æ¸…é™¤ç¼“å­˜ï¼Œå› ä¸ºæœ‰æ–°ä»»åŠ¡
      await loadTasks(currentPage, 'none', true); // å¼ºåˆ¶åˆ·æ–°

      // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
      alert(`ä»»åŠ¡å…‹éš†æˆåŠŸï¼æ–°ä»»åŠ¡ID: ${result.task.id}`);

    } catch (error) {
      console.error('å…‹éš†ä»»åŠ¡å¤±è´¥:', error);
      alert(error instanceof Error ? error.message : 'å…‹éš†ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setCloning(false);
    }
  };

  // ğŸ†• å¤šé€‰åŠŸèƒ½å¤„ç†å‡½æ•°
  const toggleMultiSelectMode = () => {
    setIsMultiSelectMode(!isMultiSelectMode);
    setSelectedTasks(new Set()); // æ¸…ç©ºé€‰æ‹©
  };

  const handleTaskSelect = (taskId: string, selected: boolean) => {
    const newSelected = new Set(selectedTasks);
    if (selected) {
      newSelected.add(taskId);
    } else {
      newSelected.delete(taskId);
    }
    setSelectedTasks(newSelected);
    
    // è§¦å‘å…¼å®¹æ€§æ£€æµ‹
    const selectedIds = Array.from(newSelected);
    checkSelectedTasksCompatibility(selectedIds);
  };

  const handleSelectAll = (checked: boolean) => {
    let newSelected: Set<string>;
    if (checked) {
      // åªé€‰æ‹©å·²å®Œæˆçš„ä»»åŠ¡
      const completedTaskIds = tasks
        .filter(task => task.status === 'completed')
        .map(task => task.id);
      newSelected = new Set(completedTaskIds);
      setSelectedTasks(newSelected);
    } else {
      newSelected = new Set();
      setSelectedTasks(newSelected);
    }
    
    // è§¦å‘å…¼å®¹æ€§æ£€æµ‹
    checkSelectedTasksCompatibility(Array.from(newSelected));
  };

  const getSelectedCompletedTasks = () => {
    return tasks.filter(task => 
      selectedTasks.has(task.id) && task.status === 'completed'
    );
  };

  // ğŸ†• æ£€æµ‹èšåˆå…¼å®¹æ€§
  const checkSelectedTasksCompatibility = async (taskIds: string[]) => {
    if (taskIds.length < 2) {
      setAggregationCompatibility(null);
      setSelectedTasksInfo([]);
      return;
    }

    setLoadingCompatibility(true);
    try {
      const response = await fetch('/api/tasks/aggregation-info', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ taskIds }),
      });

      if (!response.ok) {
        throw new Error('è·å–ä»»åŠ¡ä¿¡æ¯å¤±è´¥');
      }

      const data = await response.json();
      if (data.success && data.tasks) {
        setSelectedTasksInfo(data.tasks);
        const compatibility = checkAggregationCompatibility(data.tasks);
        setAggregationCompatibility(compatibility);
      }
    } catch (error) {
      console.error('æ£€æµ‹èšåˆå…¼å®¹æ€§å¤±è´¥:', error);
      setAggregationCompatibility(null);
      setSelectedTasksInfo([]);
    } finally {
      setLoadingCompatibility(false);
    }
  };

  const handleCreateAggregation = () => {
    const selectedCompletedTasks = getSelectedCompletedTasks();
    if (selectedCompletedTasks.length < 2) {
      alert('è¯·è‡³å°‘é€‰æ‹©2ä¸ªå·²å®Œæˆçš„ä»»åŠ¡è¿›è¡Œèšåˆåˆ†æ');
      return;
    }
    
    if (!aggregationCompatibility || (!aggregationCompatibility.canVertical && !aggregationCompatibility.canHorizontal)) {
      alert('é€‰ä¸­çš„ä»»åŠ¡æ— æ³•è¿›è¡Œèšåˆåˆ†æï¼Œè¯·æ£€æŸ¥ä»»åŠ¡å…¼å®¹æ€§');
      return;
    }
    
    if (!selectedTasksInfo || selectedTasksInfo.length === 0) {
      alert('ç¼ºå°‘ä»»åŠ¡ä¿¡æ¯ï¼Œè¯·é‡æ–°é€‰æ‹©ä»»åŠ¡');
      return;
    }

    // åˆ›å»ºèšåˆåˆ†æ
    try {
      // ç¡®å®šèšåˆç±»å‹ï¼ˆä¼˜å…ˆçºµå‘èšåˆï¼‰
      const aggregationType: AggregationType = aggregationCompatibility.canVertical 
        ? AggregationType.VERTICAL 
        : AggregationType.HORIZONTAL;

      // ç”Ÿæˆèšåˆåˆ†æé…ç½®
      const aggregationId = createAggregationId(selectedTasksInfo.map(t => t.id));
      const now = new Date().toISOString();
      
      const models = aggregationType === AggregationType.VERTICAL
        ? mergeModelsForVerticalAggregation(selectedTasksInfo)
        : selectedTasksInfo[0]?.models || [];
        
      const dimensions = aggregationType === AggregationType.HORIZONTAL
        ? mergeDimensionsForHorizontalAggregation(selectedTasksInfo)
        : selectedTasksInfo[0]?.dimensions || [];

      const aggregationConfig = {
        id: aggregationId,
        name: `èšåˆåˆ†æ_${new Date().getTime()}`,
        type: aggregationType,
        taskIds: selectedTasksInfo.map(t => t.id),
        taskNames: selectedTasksInfo.map(t => t.name),
        createdAt: now,
        modelCount: models.length,
        dimensionCount: dimensions.length,
        models: models,
        dimensions: dimensions,
        tasksInfo: selectedTasksInfo,
        compatibility: aggregationCompatibility
      };

      // ä¿å­˜åˆ°localStorage
      const saved = localStorage.getItem('aggregation_analyses');
      const analyses = saved ? JSON.parse(saved) : [];
      analyses.push(aggregationConfig);
      localStorage.setItem('aggregation_analyses', JSON.stringify(analyses));

      // è·³è½¬åˆ°èšåˆåˆ†æé¡µé¢
      router.push('/workbench/aggregation');

    } catch (error) {
      console.error('åˆ›å»ºèšåˆåˆ†æå¤±è´¥:', error);
      alert('åˆ›å»ºèšåˆåˆ†æå¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'running':
        return <Activity className="h-4 w-4 text-blue-500" />;
      case 'completed':
        return <CheckCircle className="h-4 w-4 text-green-500" />;
      case 'failed':
        return <XCircle className="h-4 w-4 text-red-500" />;
      default:
        return <Clock className="h-4 w-4 text-gray-400" />;
    }
  };

  const getStatusText = (status: string) => {
    switch (status) {
      case 'running':
        return 'è¿è¡Œä¸­';
      case 'completed':
        return 'å·²å®Œæˆ';
      case 'failed':
        return 'å¤±è´¥';
      case 'cancelled':
        return 'å·²å–æ¶ˆ';
      default:
        return 'ç­‰å¾…ä¸­';
    }
  };

  // ğŸ†• è·å–ä»»åŠ¡ç±»å‹ä¿¡æ¯
  const getTaskType = (task: Task) => {
    const runCount = task.config?.run_count || 1;
    return {
      isMultiRun: runCount > 1,
      runCount: runCount,
      label: runCount > 1 ? `å¤šæ¬¡è¿è¡Œ (${runCount}æ¬¡)` : 'å•æ¬¡è¿è¡Œ',
      badgeColor: runCount > 1 ? 'bg-purple-100 text-purple-800' : 'bg-gray-100 text-gray-600'
    };
  };

  // ğŸ†• æ ¼å¼åŒ–ä»»åŠ¡æˆæœ¬æ˜¾ç¤º
  const formatTaskCost = (task: Task) => {
    if (!task.cost_summary || !task.cost_summary.has_cost_data) {
      return '-';
    }

    const cost = currency === 'USD' 
      ? task.cost_summary.total_cost_usd 
      : task.cost_summary.total_cost_cny;
    
    return formatCost(cost, currency, 4);
  };

  // ğŸ†• åŠ è½½ä»»åŠ¡æˆæœ¬ä¿¡æ¯
  const loadTaskCostSummary = async (taskId: string): Promise<any> => {
    try {
      const response = await fetch(`/api/tasks/${taskId}/cost-summary`);
      if (response.ok) {
        const data = await response.json();
        return data.cost_summary;
      }
    } catch (error) {
      console.warn(`åŠ è½½ä»»åŠ¡ ${taskId} æˆæœ¬ä¿¡æ¯å¤±è´¥:`, error);
    }
    return null;
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'running':
        return 'bg-blue-100 text-blue-800';
      case 'completed':
        return 'bg-green-100 text-green-800';
      case 'failed':
        return 'bg-red-100 text-red-800';
      case 'cancelled':
        return 'bg-gray-100 text-gray-800';
      default:
        return 'bg-yellow-100 text-yellow-800';
    }
  };

  const getProgressPercentage = (task: Task) => {
    if (task.progress.total === 0) return 0;
    return Math.round((task.progress.completed / task.progress.total) * 100);
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-lg text-gray-600">åŠ è½½ä¸­...</div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* æ“ä½œæŒ‰é’® */}
      <div className="flex items-center justify-end">
        <div className="flex space-x-3">
            {/* ğŸ†• å¤šé€‰æ¨¡å¼åˆ‡æ¢æŒ‰é’® */}
            <Button 
              variant={isMultiSelectMode ? "default" : "outline"}
              onClick={toggleMultiSelectMode}
            >
              <BarChart3 className="mr-2 h-4 w-4" />
              {isMultiSelectMode ? 'é€€å‡ºå¤šé€‰' : 'èšåˆåˆ†æ'}
            </Button>
            
            {/* ğŸ†• èšåˆåˆ†ææŒ‰é’® - ä»…åœ¨å¤šé€‰æ¨¡å¼ä¸”æœ‰é€‰æ‹©æ—¶æ˜¾ç¤º */}
            {isMultiSelectMode && selectedTasks.size >= 2 && (
              <div className="flex items-center space-x-2">
                <Button 
                  onClick={handleCreateAggregation}
                  disabled={loadingCompatibility || !aggregationCompatibility || (!aggregationCompatibility.canVertical && !aggregationCompatibility.canHorizontal)}
                  className={`${
                    aggregationCompatibility && (aggregationCompatibility.canVertical || aggregationCompatibility.canHorizontal)
                      ? 'bg-purple-600 hover:bg-purple-700' 
                      : 'bg-gray-400'
                  }`}
                >
                  {loadingCompatibility ? (
                    <>
                      <RefreshCw className="mr-2 h-4 w-4 animate-spin" />
                      æ£€æµ‹ä¸­...
                    </>
                  ) : (
                    <>
                      <BarChart3 className="mr-2 h-4 w-4" />
                      åˆ›å»ºèšåˆåˆ†æ ({getSelectedCompletedTasks().length})
                    </>
                  )}
                </Button>
                
                {/* å…¼å®¹æ€§æç¤º */}
                {aggregationCompatibility && selectedTasks.size >= 2 && (
                  <div className="text-xs">
                    {aggregationCompatibility.canVertical && (
                      <span className="text-green-600 mr-2">âœ“ çºµå‘èšåˆ</span>
                    )}
                    {aggregationCompatibility.canHorizontal && (
                      <span className="text-green-600">âœ“ æ¨ªå‘èšåˆ</span>
                    )}
                    {!aggregationCompatibility.canVertical && !aggregationCompatibility.canHorizontal && (
                      <span className="text-red-600">âœ— ä¸å…¼å®¹</span>
                    )}
                  </div>
                )}
              </div>
            )}
            
            <Button 
              variant="outline" 
              onClick={handleRefresh}
              disabled={refreshing}
            >
              <RefreshCw className={`mr-2 h-4 w-4 ${refreshing ? 'animate-spin' : ''}`} />
              åˆ·æ–°
            </Button>
            <Link href="/workbench/tasks/new">
              <Button>
                <PlusCircle className="mr-2 h-4 w-4" />
                æ–°å»ºè¯„æµ‹ä»»åŠ¡
              </Button>
            </Link>
          </div>
        </div>

        {/* é”™è¯¯æç¤º */}
        {error && (
          <div className="bg-red-50 border border-red-200 rounded-md p-4">
            <div className="flex">
              <XCircle className="h-5 w-5 text-red-400" />
              <div className="ml-3">
                <h3 className="text-sm font-medium text-red-800">åŠ è½½å¤±è´¥</h3>
                <div className="mt-2 text-sm text-red-700">{error}</div>
                <div className="mt-4">
                  <Button variant="outline" size="sm" onClick={handleRefresh}>
                    é‡è¯•
                  </Button>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* ğŸ†• ç­›é€‰å’Œæœç´¢åŒºåŸŸ */}
        <div className="bg-white shadow rounded-lg p-6">
          <div className="flex flex-col sm:flex-row gap-4">
            {/* æœç´¢æ¡† */}
            <div className="flex-1">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                <input
                  type="text"
                  placeholder="æœç´¢ä»»åŠ¡åç§°..."
                  value={searchName}
                  onChange={(e) => setSearchName(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
                  className="pl-10 pr-4 py-2 w-full border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
            </div>

            {/* çŠ¶æ€ç­›é€‰ */}
            <div className="sm:w-40">
              <select
                value={statusFilter}
                onChange={(e) => handleFilterChange('status', e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              >
                <option value="all">æ‰€æœ‰çŠ¶æ€</option>
                <option value="pending">ç­‰å¾…ä¸­</option>
                <option value="running">è¿è¡Œä¸­</option>
                <option value="completed">å·²å®Œæˆ</option>
                <option value="failed">å¤±è´¥</option>
                <option value="cancelled">å·²å–æ¶ˆ</option>
              </select>
            </div>

            {/* ç±»å‹ç­›é€‰ */}
            <div className="sm:w-40">
              <select
                value={typeFilter}
                onChange={(e) => handleFilterChange('type', e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              >
                <option value="all">æ‰€æœ‰ç±»å‹</option>
                <option value="single">å•æ¬¡è¿è¡Œ</option>
                <option value="multi">å¤šæ¬¡è¿è¡Œ</option>
              </select>
            </div>

            {/* æœç´¢æŒ‰é’® */}
            <Button onClick={handleSearch} className="sm:w-auto">
              <Search className="mr-2 h-4 w-4" />
              æœç´¢
            </Button>
          </div>

          {/* ç»“æœç»Ÿè®¡ */}
          <div className="mt-4 flex items-center justify-between">
            <div className="text-sm text-gray-500">
              å…±æ‰¾åˆ° {totalTasks} ä¸ªä»»åŠ¡ï¼Œå½“å‰æ˜¾ç¤ºç¬¬ {currentPage} é¡µï¼Œå…± {totalPages} é¡µ
            </div>

          </div>
        </div>

        {/* ç»Ÿè®¡å¡ç‰‡ */}
        <div className="grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-5">
          <div className="bg-white overflow-hidden shadow rounded-lg">
            <div className="p-5">
              <div className="flex items-center">
                <div className="flex-shrink-0">
                  <Play className="h-6 w-6 text-gray-400" />
                </div>
                <div className="ml-5 w-0 flex-1">
                  <dl>
                    <dt className="text-sm font-medium text-gray-500 truncate">
                      æ€»ä»»åŠ¡æ•°
                    </dt>
                    <dd className="text-lg font-medium text-gray-900">
                      {stats.total}
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>

          <div className="bg-white overflow-hidden shadow rounded-lg">
            <div className="p-5">
              <div className="flex items-center">
                <div className="flex-shrink-0">
                  <Clock className="h-6 w-6 text-yellow-500" />
                </div>
                <div className="ml-5 w-0 flex-1">
                  <dl>
                    <dt className="text-sm font-medium text-gray-500 truncate">
                      ç­‰å¾…ä¸­
                    </dt>
                    <dd className="text-lg font-medium text-gray-900">
                      {stats.pending}
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>

          <div className="bg-white overflow-hidden shadow rounded-lg">
            <div className="p-5">
              <div className="flex items-center">
                <div className="flex-shrink-0">
                  <Activity className="h-6 w-6 text-blue-500" />
                </div>
                <div className="ml-5 w-0 flex-1">
                  <dl>
                    <dt className="text-sm font-medium text-gray-500 truncate">
                      è¿è¡Œä¸­
                    </dt>
                    <dd className="text-lg font-medium text-gray-900">
                      {stats.running}
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>

          <div className="bg-white overflow-hidden shadow rounded-lg">
            <div className="p-5">
              <div className="flex items-center">
                <div className="flex-shrink-0">
                  <CheckCircle className="h-6 w-6 text-green-500" />
                </div>
                <div className="ml-5 w-0 flex-1">
                  <dl>
                    <dt className="text-sm font-medium text-gray-500 truncate">
                      å·²å®Œæˆ
                    </dt>
                    <dd className="text-lg font-medium text-gray-900">
                      {stats.completed}
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>

          <div className="bg-white overflow-hidden shadow rounded-lg">
            <div className="p-5">
              <div className="flex items-center">
                <div className="flex-shrink-0">
                  <XCircle className="h-6 w-6 text-red-500" />
                </div>
                <div className="ml-5 w-0 flex-1">
                  <dl>
                    <dt className="text-sm font-medium text-gray-500 truncate">
                      å¤±è´¥
                    </dt>
                    <dd className="text-lg font-medium text-gray-900">
                      {stats.failed}
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* ä»»åŠ¡åˆ—è¡¨ */}
        <div className="bg-white shadow overflow-hidden sm:rounded-md">
          <div className="px-4 py-5 sm:px-6">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-lg leading-6 font-medium text-gray-900">
                  æœ€è¿‘ä»»åŠ¡
                </h3>
                <p className="mt-1 max-w-2xl text-sm text-gray-500">
                  æœ€æ–°åˆ›å»ºå’Œè¿è¡Œçš„è¯„æµ‹ä»»åŠ¡
                </p>
              </div>
              
              {/* ğŸ†• å¤šé€‰æ¨¡å¼ä¸‹æ˜¾ç¤ºå…¨é€‰å¤é€‰æ¡†å’Œç»Ÿè®¡ä¿¡æ¯ */}
              {isMultiSelectMode && (
                <div className="flex items-center space-x-4">
                  <div className="text-sm text-gray-600">
                    å·²é€‰æ‹© {selectedTasks.size} / {tasks.filter(t => t.status === 'completed').length} ä¸ªå·²å®Œæˆä»»åŠ¡
                  </div>
                  <div className="flex items-center">
                    <input
                      type="checkbox"
                      id="selectAll"
                      checked={selectedTasks.size > 0 && selectedTasks.size === tasks.filter(t => t.status === 'completed').length}
                      onChange={(e) => handleSelectAll(e.target.checked)}
                      className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                    />
                    <label htmlFor="selectAll" className="ml-2 text-sm font-medium text-gray-700">
                      å…¨é€‰å·²å®Œæˆä»»åŠ¡
                    </label>
                  </div>
                </div>
              )}
            </div>
          </div>

          {/* ğŸ†• å±€éƒ¨loadingæŒ‡ç¤ºå™¨ */}
          <div className={`relative ${paginationLoading ? 'opacity-60' : ''} transition-opacity duration-200`}>
            {paginationLoading && (
              <div className="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center z-10">
                <div className="flex items-center space-x-2 text-blue-600">
                  <RefreshCw className="h-4 w-4 animate-spin" />
                  <span className="text-sm">åŠ è½½ä¸­...</span>
                </div>
              </div>
            )}

            <ul className="divide-y divide-gray-200">
            {tasks.map((task) => (
              <li key={task.id} className="relative">
                <div className={`flex items-center ${!isMultiSelectMode ? 'hover:bg-gray-50' : ''}`}>
                  {/* ğŸ†• å¤šé€‰æ¨¡å¼ä¸‹æ˜¾ç¤ºå¤é€‰æ¡† */}
                  {isMultiSelectMode && (
                    <div className="px-4 py-4 flex-shrink-0">
                      <input
                        type="checkbox"
                        checked={selectedTasks.has(task.id)}
                        disabled={task.status !== 'completed'}
                        onChange={(e) => {
                          e.stopPropagation();
                          handleTaskSelect(task.id, e.target.checked);
                        }}
                        className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded disabled:opacity-50"
                      />
                    </div>
                  )}
                  
                  <Link 
                    href={`/workbench/tasks/${task.id}`} 
                    className={`block flex-1 ${!isMultiSelectMode ? 'hover:bg-gray-50' : ''}`}
                  >
                    <div className="px-4 py-4 sm:px-6">
                      <div className="flex items-center justify-between">
                        <div className="flex items-center">
                          {getStatusIcon(task.status)}
                          <p className="ml-2 text-sm font-medium text-gray-900 truncate">
                            {task.name}
                          </p>
                        {/* ğŸ†• ä»»åŠ¡ç±»å‹æ ‡ç­¾ */}
                        <span className={`ml-2 px-2 inline-flex text-xs leading-5 font-medium rounded-full ${getTaskType(task).badgeColor}`}>
                          {getTaskType(task).label}
                        </span>
                        {/* ğŸ†• æˆæœ¬æ ‡ç­¾ */}
                        <span className="ml-2 px-2 inline-flex text-xs leading-5 font-medium rounded-full bg-green-100 text-green-800">
                          <DollarSign className="w-3 h-3 mr-1" />
                          {formatTaskCost(task)}
                        </span>
                      </div>
                      <div className="ml-2 flex-shrink-0 flex items-center space-x-2">
                        <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${getStatusColor(task.status)}`}>
                          {getStatusText(task.status)}
                        </span>
                        {/* ğŸ†• å…‹éš†æŒ‰é’® */}
                        <button
                          onClick={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            handleCloneTask(task.id, task.name);
                          }}
                          className="inline-flex items-center p-1.5 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded transition-all duration-200"
                          title="å…‹éš†ä»»åŠ¡"
                        >
                          <Copy className="h-4 w-4" />
                        </button>
                      </div>
                    </div>
                    <div className="mt-2 sm:flex sm:justify-between">
                      <div className="sm:flex">
                        <p className="flex items-center text-sm text-gray-500">
                          åˆ›å»ºæ—¶é—´: {new Date(task.created_at).toLocaleString('zh-CN')}
                        </p>
                      </div>
                      <div className="mt-2 flex items-center text-sm text-gray-500 sm:mt-0">
                        {task.status === 'running' && task.progress.total > 0 && (
                          <div className="flex items-center">
                            <span className="mr-2">è¿›åº¦: {task.progress.completed}/{task.progress.total}</span>
                            <div className="w-20 bg-gray-200 rounded-full h-2">
                              <div 
                                className="bg-blue-600 h-2 rounded-full transition-all duration-300" 
                                style={{ width: `${getProgressPercentage(task)}%` }}
                              ></div>
                            </div>
                            <span className="ml-2 text-xs">{getProgressPercentage(task)}%</span>
                          </div>
                        )}
                        {task.status === 'completed' && task.finished_at && (
                          <span>å®Œæˆæ—¶é—´: {new Date(task.finished_at).toLocaleString('zh-CN')}</span>
                        )}
                      </div>
                    </div>
                    </div>
                  </Link>
                </div>
              </li>
            ))}
          </ul>
          {tasks.length === 0 && !error && (
            <div className="text-center py-12">
              <Play className="mx-auto h-12 w-12 text-gray-400" />
              <h3 className="mt-2 text-sm font-medium text-gray-900">æš‚æ— ä»»åŠ¡</h3>
              <p className="mt-1 text-sm text-gray-500">
                å¼€å§‹åˆ›å»ºæ‚¨çš„ç¬¬ä¸€ä¸ªè¯„æµ‹ä»»åŠ¡
              </p>
              <div className="mt-6">
                <Link href="/workbench/tasks/new">
                  <Button>
                    <PlusCircle className="mr-2 h-4 w-4" />
                    æ–°å»ºè¯„æµ‹ä»»åŠ¡
                  </Button>
                </Link>
              </div>
            </div>
          )}

          {/* ğŸ†• åˆ†é¡µç»„ä»¶ */}
          {totalPages > 1 && (
            <div className="px-4 py-3 border-t border-gray-200 bg-gray-50 flex items-center justify-between">
              <div className="text-sm text-gray-700">
                æ˜¾ç¤ºç¬¬ {(currentPage - 1) * pageSize + 1} - {Math.min(currentPage * pageSize, totalTasks)} é¡¹ï¼Œå…± {totalTasks} é¡¹
              </div>

              <div className="flex items-center space-x-2">
                {/* ä¸Šä¸€é¡µ */}
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handlePageChange(currentPage - 1)}
                  disabled={currentPage <= 1}
                >
                  <ChevronLeft className="h-4 w-4" />
                  ä¸Šä¸€é¡µ
                </Button>

                {/* é¡µç  */}
                <div className="flex items-center space-x-1">
                  {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
                    let pageNum;
                    if (totalPages <= 5) {
                      pageNum = i + 1;
                    } else if (currentPage <= 3) {
                      pageNum = i + 1;
                    } else if (currentPage >= totalPages - 2) {
                      pageNum = totalPages - 4 + i;
                    } else {
                      pageNum = currentPage - 2 + i;
                    }

                    return (
                      <button
                        key={pageNum}
                        onClick={() => handlePageChange(pageNum)}
                        className={`px-3 py-1 text-sm rounded ${
                          pageNum === currentPage
                            ? 'bg-blue-600 text-white'
                            : 'bg-white text-gray-700 hover:bg-gray-50 border border-gray-300'
                        }`}
                      >
                        {pageNum}
                      </button>
                    );
                  })}
                </div>

                {/* ä¸‹ä¸€é¡µ */}
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handlePageChange(currentPage + 1)}
                  disabled={currentPage >= totalPages}
                >
                  ä¸‹ä¸€é¡µ
                  <ChevronRight className="h-4 w-4" />
                </Button>
              </div>
            </div>
          )}
          </div> {/* ğŸ†• å…³é—­å±€éƒ¨loadingå®¹å™¨ */}
        </div>

        {/* ğŸ†• å…‹éš†ä»»åŠ¡å¯¹è¯æ¡† */}
        {showCloneDialog && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-white rounded-lg max-w-md w-full p-6">
              <h3 className="text-lg font-semibold text-gray-900 mb-4">å…‹éš†ä»»åŠ¡</h3>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    æ–°ä»»åŠ¡åç§°
                  </label>
                  <input
                    type="text"
                    value={cloneTaskName}
                    onChange={(e) => setCloneTaskName(e.target.value)}
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                    placeholder="è¯·è¾“å…¥æ–°ä»»åŠ¡åç§°"
                    autoFocus
                  />
                </div>

                <div className="text-sm text-gray-500">
                  å°†å¤åˆ¶åŸä»»åŠ¡çš„æ‰€æœ‰é…ç½®ï¼ŒåŒ…æ‹¬æ¨¡æ¿ã€æ¨¡å‹ã€æµ‹è¯•ç”¨ä¾‹ç­‰è®¾ç½®ã€‚
                </div>
              </div>

              <div className="flex justify-end space-x-3 mt-6">
                <Button
                  variant="outline"
                  onClick={() => {
                    setShowCloneDialog(false);
                    setCloneTaskId(null);
                    setCloneTaskName('');
                  }}
                  disabled={cloning}
                >
                  å–æ¶ˆ
                </Button>
                <Button
                  onClick={executeCloneTask}
                  disabled={cloning || !cloneTaskName.trim()}
                >
                  {cloning ? (
                    <>
                      <RefreshCw className="mr-2 h-4 w-4 animate-spin" />
                      å…‹éš†ä¸­...
                    </>
                  ) : (
                    <>
                      <Copy className="mr-2 h-4 w-4" />
                      ç¡®è®¤å…‹éš†
                    </>
                  )}
                </Button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}